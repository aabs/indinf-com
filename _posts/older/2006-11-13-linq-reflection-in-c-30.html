---
layout: post
title: LINQ & Reflection in C# 3.0
date: 2006-11-13 18:33:34.000000000 +11:00
type: post
published: true
status: publish
categories: []
tags:
- C#
- Code Generation
meta: {}
author:
  login: aabs
  email: matthews.andrew@gmail.com
  display_name: Andrew Matthews
  first_name: Andrew
  last_name: Matthews
---
<p>I posted an article the other day showing you how to exploit the query<br />
capabilities of LINQ to do reflection over the attributes on a C# class. I want<br />
to show you how to exploit some of the extension methods in System.Query to make<br />
the code even cleaner. I used a method called Members that got all of the<br />
members in order of member type (i.e. fields first, properties next and so on).<br />
The code looked like this:</p>
<p><span style="font-size:10pt;font-family:Courier New;"></span><span style="color:blue;"></p>
<pre><span style="color:blue;">
<pre><span style="color:blue;">public</span> <span style="color:blue;">static</span> IEnumerable&lt;MemberInfo&gt;Members(<span style="color:blue;">this</span> Type t) 
{ 
    <span style="color:blue;">foreach</span> (FieldInfo fi <span style="color:blue;">in</span> t.GetFields()) 
        <span style="color:blue;">yield</span> <span style="color:blue;">return</span> fi; 
    <span style="color:blue;">foreach</span> (PropertyInfo pi <span style="color:blue;">in</span> t.GetProperties()) 
        <span style="color:blue;">yield</span> <span style="color:blue;">return</span> pi; 
    <span style="color:blue;">foreach</span> (MethodInfo mi <span style="color:blue;">in</span> t.GetMethods()) 
        <span style="color:blue;">yield</span> <span style="color:blue;">return</span> mi; 
    <span style="color:blue;">foreach</span> (EventInfo ei <span style="color:blue;">in</span> t.GetEvents()) 
        <span style="color:blue;">yield</span> <span style="color:blue;">return</span> ei; 
}</pre>
<p></span><br />
</span></p>
<p>I needed to split the queries into each of the types we required in order to<br />
get elements ordered by type. Well System.Query provides a neater way to do this<br />
sort of thing. As luck would have it, I don't care what order I bring the<br />
members back in so long as they are grouped by type and then by name. We can use<br />
the ordering queries in LINQ to do this:</p>
<p><span style="font-size:10pt;font-family:Courier New;"></span><span style="color:blue;"></p>
<pre><span style="color:blue;">foreach</span> (MemberInfo mi <span style="color:blue;">in</span> from m <span style="color:blue;">in</span> t.GetMembers() orderby m.GetType().Name, m.Name select m) 
{ 
    <span style="color:blue;">yield</span> <span style="color:blue;">return</span> mi; 
}</pre>
<p></span></p>
<p>Much cleaner, and it also grabs the constructors which I forgot to add in the<br />
previous post! ;-) The query syntax there is equivalent to the following C# 2.0<br />
syntax:</p>
<p><span style="font-size:10pt;font-family:Courier New;"></span><span style="color:blue;"></span><span style="color:blue;"></p>
<pre><span style="color:blue;">foreach</span> (MemberInfo mi <span style="color:blue;">in</span> t.GetMembers().OrderBy(a =&gt; a.GetType().Name).ThenBy(b =&gt; b.Name)) 
{ 
    <span style="color:blue;">yield</span> <span style="color:blue;">return</span> mi; 
}</pre>
<p>I can impose some specific order by using the union method:</p>
<p></span><span style="font-size:10pt;font-family:Courier New;"></span><span style="color:blue;"></span><span style="color:blue;"></p>
<pre><span style="color:blue;">foreach</span> (MemberInfo mi <span style="color:blue;">in</span> t.GetFields().Union&lt;MemberInfo&gt;(t.GetProperties().Union&lt;MemberInfo&gt;(t.GetMethods()))) 
{ 
    <span style="color:blue;">yield</span> <span style="color:blue;">return</span> mi; 
}</pre>
<p>We can mix and match these operators since they are all extension<br />
methods on the IEnumerable&lt;T&gt; or IEnumerable types. The methods are<br />
defined in System.Query.Sequence, so you can use the object browser or reflector<br />
to find out what's available.</p>
<p></span>In the code generation patterns posts I wrote last year, I demonstrated that<br />
we often need to recursively enumerate structural elements in assemblies or<br />
databases. Here is an untyped example of how we can apply these enumerators to<br />
simply dig through the capabilities of the type:</p>
<p><span style="font-size:10pt;font-family:Courier New;"></span><span style="color:blue;"></p>
<pre><span style="color:blue;">public</span> <span style="color:blue;">static</span> IEnumerable&lt;<span style="color:blue;">object</span>&gt; ParseType(Type t) 
{ 
    <span style="color:blue;">foreach</span> (MemberInfo mi <span style="color:blue;">in</span> t.Members()) 
    { 
        <span style="color:blue;">yield</span> <span style="color:blue;">return</span> mi; 
        <span style="color:blue;">foreach</span> (<span style="color:blue;">object</span> x <span style="color:blue;">in</span> mi.Attributes&lt;DbcPredicateAttribute&gt;()) 
        { 
            <span style="color:blue;">yield</span> <span style="color:blue;">return</span> x; 
        } 
    } 
}</pre>
<p></span></p>
<p>You can see that now the code required to enumerate the type is very simple.<br />
But we haven't gained simplicity at the expense of power. We can explore the<br />
object in any way we please.</p>
