---
layout: post
title: Creating A LINQ Query Provider
date: 2007-05-18 09:20:58.000000000 +10:00
type: post
published: true
status: publish
categories: []
tags:
- artificial intelligence
- C#
- Computer Science
- databases
- LINQ
- ORM
- programming
- software
meta: {}
author:
  login: aabs
  email: matthews.andrew@gmail.com
  display_name: Andrew Matthews
  first_name: Andrew
  last_name: Matthews
---
<p>As promised last time, I have extended the query mechanism of my little application with a LINQ Query Provider. I based my initial design on the method published by <a href="http://community.bartdesmet.net/blogs/bart/archive/2007/04/05/the-iqueryable-tales-linq-to-ldap-part-0.aspx">Bart De Smet</a>, but have extended that framework, cleaned it up and tied it in with the original object deserialiser for <a href="http://razor.occams.info/code/semweb/">SemWeb </a>(a semantic web library by <a href="http://razor.occams.info/blog">Joshua Tauberer</a>).</p>
<p>In this post I'll give you some edited highlights of what was involved. You may recal that last post I provided some unit tests that i was working with. For the sake of initial simplicity (and to make it easy to produce queries with SemWeb's GraphMatch algorithm) I restricted my query language to make use of Conjunction, and Equality. here's the unit test that I worked with to drive the development process. What I produced last time was a simple scanner that went through my podcasts extracting metadata and creating objects of type Track.</p>
<p><code>[TestMethod]<br />
public void QueryWithProjection()<br />
{<br />
CreateMemoryStore();<br />
IRdfQuery&lt;Track&gt; qry = new RdfContext(store).ForType&lt;Track&gt;();<br />
var q = from t in qry<br />
where t.Year == 2006 &amp;&amp;<br />
t.GenreName == "History 5 | Fall 2006 | UC Berkeley"<br />
select new {t.Title, t.FileLocation};<br />
foreach(var track in q){<br />
Trace.WriteLine(track.Title + ": " + track.FileLocation);<br />
}<br />
}</code></p>
<p>This method queries the Tracks collection in an in-memory triple store loaded from a file in N3 format. It searches for any UC Berkley pod-casts produced in 2006, and performs a projection to create a new anonymous type containing the title and location of the files.</p>
<p>I took a leaf from the book of LINQ to SQL to crate the query object. In LINQ to SQL you indicate the type you are working with using a Table&lt;T&gt; class. In my query context class, you identify the type you are working with using a ForType&lt;T&gt;() method. this method instantiates a query object for you, and (in future) will act as an object registry to keep track of object updates.</p>
<p>The RDFContext class is very simple:</p>
<p><code>public class RdfContext : IRdfContext<br />
{<br />
public Store Store<br />
{<br />
get { return store; }<br />
set { store = value; }<br />
}<br />
protected Store store;<br />
public RdfContext(Store store)<br />
{<br />
this.store = store;<br />
}<br />
public void AcceptChanges()<br />
{<br />
throw new NotImplementedException();<br />
}<br />
public IRdfQuery&lt;T&gt; ForType&lt;T&gt;()<br />
{<br />
return new RdfN3Query&lt;T&gt;(store);<br />
}<br />
}</code></p>
<p>As you can see, it is pretty bare at the moment. It maintains a reference to the store, and instantiates query objects for you. But in future this would be the place to create transactional support, and perhaps maintain connections to triple stores. By and large, though, this class will be pretty simple in comparison to the query class that is to follow.</p>
<p>I won't repeat all of what Bart De Smet said in his excellent series of articles on the production of LINQ to LDAP. I'll confine myself to this implementation, and how it works. So we have to start by creating our Query Object:</p>
<p><code>public class RdfN3Query&lt;T&gt; : IRdfQuery&lt;T&gt;<br />
{<br />
public RdfN3Query(Store store)<br />
{<br />
this.store = store;<br />
this.originalType = typeof (T);<br />
parser = new ExpressionNodeParser&lt;T&gt;();<br />
}</code></p>
<p>First it stores a reference to the triple store for later use. In a more real world implementation this might be a URL or connection string. But for the sake of this implementation, we can be happy with the Memory Store that is used in the unit test. next we keep a record of the original type that is being queried against. this is important because later on you may also be dealing with a new anonymous type that will be created by the projection. This will not have any of the Owl*Attribute classes with which to work out URLs for properties and to perform deserialisation.</p>
<p>The two most important methods in IQueryable&lt;T&gt; are CreateQuery and GetEnumerable. CreateQuery is the place where LINQ feeds you the expression tree that it has built from  your initial query. You must parse this expression tree and store the resultant query somewhere for later use. I created a string called query to keep that in, and created a class called ExpressionNodeParser to walk the expression tree to build tyhe query string. This is equivalent to the stage where the SQL SELECT query gets created in DLINQ. My CreateQuery looks like this:</p>
<p><code>public IQueryable&lt;TElement&gt; CreateQuery&lt;TElement&gt;(Expression expression)<br />
{<br />
RdfN3Query&lt;TElement&gt; newQuery = new RdfN3Query&lt;TElement&gt;(store);<br />
newQuery.OriginalType = originalType;<br />
newQuery.Project = project;<br />
newQuery.Properties = properties;<br />
newQuery.Query = Query;<br />
newQuery.Logger = logger;<br />
newQuery.Parser = new ExpressionNodeParser&lt;TElement&gt;(new<br />
StringBuilder(parser.StringBuilder.ToString()));<br />
MethodCallExpression call = expression as MethodCallExpression;<br />
if (call != null)<br />
{<br />
switch (call.Method.Name)<br />
{<br />
case "Where":<br />
Log("Processing the where expression");<br />
newQuery.BuildQuery(call.Parameters[1]);<br />
break;<br />
case "Select":<br />
Log("Processing the select expression");<br />
newQuery.BuildProjection(call);<br />
break;<br />
}<br />
}<br />
return newQuery;<br />
}</code></p>
<p>You create new query because you may be doing a projection, in which case the type you are enumerating over will not be the original type that you put into ForType&lt;T&gt;(). Instead it may be the anonymous type from the projection. You transfer the vital information over to the new Query object, and then handle the expression that has been passed in. I am handling two methods here: Where and Select. There are others I could handle, such as OrderBy or Take, but that will have to be for a future post.</p>
<p>Where is the part where the expression representing the query is passed in.  Select is passed the tree representing the projection (if there is one). The work is passed off to BuildQuery and BuildProjection accordingly. these names were gratefully stolen from LINQ to LDAP.</p>
<p>BuildQuery in LINQ to LDAP is a fairly complicated affair, but in LINQ to RDF I have paired it right downb to the bone.</p>
<p><code>private void BuildQuery(Expression q)<br />
{<br />
StringBuilder sb = new StringBuilder();<br />
ParseQuery(q, sb);<br />
Query = Parser.StringBuilder.ToString();<br />
Trace.WriteLine(Query);<br />
}</code></p>
<p>We create a StringBuilder that can be passed down into the recursive descent tree walker to gather the fragments of the query as each expression gets parsed.  the result is then stored in the Query property of the Query object.  BuildProjection looks like this:</p>
<p><code>private void BuildProjection(Expression expression)<br />
{<br />
LambdaExpression le = ((MethodCallExpression)expression).Parameters[1] as<br />
LambdaExpression;<br />
if (le == null)<br />
throw new ApplicationException("Incompatible expression type found when building a projection");<br />
project = le.Compile();<br />
MemberInitExpression mie = le.Body as MemberInitExpression;<br />
if (mie != null)<br />
foreach (Binding b in mie.Bindings)<br />
FindProperties(b);<br />
else<br />
foreach (PropertyInfo i in originalType.GetProperties())<br />
properties.Add(i.Name, null);<br />
}</code></p>
<p>Much of it is taken directly from LINQ to LDAP. I have adapted it slightly because I am targeting the May 2007 CTP of LINQ. I've done this only because I have to use VS 2005 during the day, so I can't use the March 2007 version of Orcas.</p>
<p>ParseQuery is used by BuildQuery to handle the walking of the expression tree.  Again that is very simple since most of the work is now done in ExpressionNodeParser. It looks like this:</p>
<p><code>private void ParseQuery(Expression expression, StringBuilder sb)<br />
{<br />
Parser.Dispatch(expression);<br />
}</code></p>
<p>Parser.Dispatch is a gigantic switch statement that passes off the expression tree to handler methods:</p>
<p><code>public void Dispatch(Expression expression)<br />
{<br />
switch (expression.NodeType)<br />
{<br />
case ExpressionType.Add:<br />
Add(expression);<br />
break;<br />
case ExpressionType.AddChecked:<br />
AddChecked(expression);<br />
break;<br />
case ExpressionType.And:<br />
And(expression);<br />
break;<br />
case ExpressionType.AndAlso:<br />
AndAlso(expression);<br />
//...</code></p>
<p>Each handler method then handles the root of the expression tree, breaking it up and passing on what it can't handle itself. For example, the method AndAlso just takes the left and right side of the operator and recursively dispatches them:</p>
<p><code>public void AndAlso(Expression e)<br />
{<br />
BinaryExpression be = e as BinaryExpression;<br />
if (be != null)<br />
{<br />
Dispatch(be.Left);<br />
Dispatch(be.Right);<br />
}<br />
}</code></p>
<p>The equality operator is the only operator that currently gets any special effort.</p>
<p><code>public void EQ(Expression e)<br />
{<br />
BinaryExpression be = e as BinaryExpression;<br />
if (be != null)<br />
{<br />
MemberExpression me = be.Left as MemberExpression;<br />
ConstantExpression ce = be.Right as ConstantExpression;<br />
QueryAppend(tripleFormatStringLiteral,<br />
InstancePlaceholderName,<br />
OwlClassSupertype.GetPropertyUri(typeof(T),<br />
me.Member.Name),<br />
ce.Value.ToString());<br />
}<br />
MethodCallExpression mce = e as MethodCallExpression;<br />
if (mce != null &amp;&amp; mce.Method.Name == "op_Equality")<br />
{<br />
MemberExpression me = mce.Parameters[0] as MemberExpression;<br />
ConstantExpression ce = mce.Parameters[1] as ConstantExpression;<br />
QueryAppend(tripleFormatStringLiteral,<br />
InstancePlaceholderName,<br />
OwlClassSupertype.GetPropertyUri(typeof(T),<br />
me.Member.Name),<br />
ce.Value.ToString());<br />
}<br />
}</code></p>
<p>The equality expression can be formed either through the use of a binary expression with NodeType.EQ or as a MethodCallExpression on op_Equality for type string. If the handler for the MethodCallExpression spots op_Equality it passes the expression off to the EQ method for it to render instead. EQ therefore needs to spot which type of Node it's dealing with to know how to get the left and right sides of the operation. In a BinaryExpression there are Right and Left properties, whereas in a MethodCallExpression these will be found in a Parameters collection. In our example they get the same treatment.</p>
<p>You'll note that we assume that the left operand is a MemberExpression and the right is a ConstantExpression. That allows us to form clauses like this:</p>
<p><code>where t.Year == 2006<br />
</code></p>
<p>but it would fail on all of the following:</p>
<p><code>where t.Name.ToUpper() == "SOME STRING"<br />
where t.Name == t.Other<br />
where t.Year.ToString() == "2006"<br />
</code></p>
<p>Each of these cases will have to be handled individually, so the number of cases we need to handle can grow. As Bart De Smet pointed out, some of the operations might have to be performed after retrieval of the results since semantic web query languages are unlikely to have complex string manipulation and arithmetic functions. Or at least, not yet.</p>
<p>The QueryAppend forms an N3 Triple out of its parameters and appends it to the StringBuilder that was passed to the Parser initially. At the end of the recursive tree walk, this string builder is harvested and preprocessed to make it ready to pass to the triple store. In my previous post I described an ObjectDeserialisationsSink that was passed to SemWeb during the query process to harvest the results. This has been reused to gather the results of the query from within our query.</p>
<p>I mentioned earlier that the GetEnumerator method was important to IQueryable.  An IQueryable is a class that can defer execution of its query till someone attempts to enumerate its results. Since that's done using GetEnumerator the query must be performed in GetEnumerator. My implementation of GetEnumerator looks like this:</p>
<p><code>IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator()<br />
{<br />
if (result != null)<br />
return result.GetEnumerator();<br />
query = ConstructQuery();<br />
PrepareQueryAndConnection();<br />
PresentQuery(query);<br />
return result.GetEnumerator();<br />
}</code></p>
<p>result is the List&lt;TElement&gt; variable where I cache the results for later use. What that means is that the query only gets run once. Next time the GetEnumerator gets called, result is returned directly. This reduces the cost of repeatedly enumerating the same query. Currently the methods ConstructQuery, PrepareQueryAndConnection, and PresentQuery are all fairly simple affairs that exist more as placeholders so that I can reuse much of this code for a LINQ to SPARQL implementation that is to follow.</p>
<p>As you've probably worked out, there is a huge amount of detail that has to be attended to, but the basic concepts are simple. the reason why more people haven't written LINQ query providers before now is simply that fact that there is no documentation about how to do it. When you try though, you may find it easier than you thought.</p>
<p>There is a great deal more to do to LINQ to RDF before something it is ready for production use, but as a proof of concept that semantic web technologies can be brought into the mainstream it serves well. Thereason why we use ORM systems such as LINQ to SQL is to help us overcome the Impedance Mismatch that exists between the object and relational domains. An equally large mismatch exists between the Object and Semantic domains. tools like LINQ to RDF will have to overcome the mismatch in order for them to be used outside of basic domain models.</p>
