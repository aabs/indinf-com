---
layout: post
title: C# puzzle of the day
date: 2006-11-05 07:50:50.000000000 +11:00
type: post
published: true
status: publish
categories: []
tags:
- Computer Science
meta: {}
author:
  login: aabs
  email: matthews.andrew@gmail.com
  display_name: Andrew Matthews
  first_name: Andrew
  last_name: Matthews
---
<p>Lately I've been exploring old prototype code I wrote year ago. It always amazes me to se how my coding style changes over the years. It also intrigues me, because it's a kind of cross between archeology and journaling. I can see what I was doing years ago. I wrote this little C++ memory simulation back in 2002, for a the memory component of a little CPU simulator:</p>
<p><code>struct memory<br />
{<br />
byte_t* mem;<br />
unsigned int size;</code><code>memory(unsigned int x = vpc::mem_size)<br />
  {<br />
  mem = new byte_t[x];<br />
  size = x;<br />
  //memset(mem, 0, size);<br />
  } <br />
~memory()<br />
  {<br />
  if(mem != 0)<br />
    {<br />
    delete mem;<br />
    mem = 0;<br />
    size = 0;<br />
    }<br />
  }</p>
<p>template&lt;typename T&gt;<br />
T get(unsigned int idx)<br />
  {<br />
  return *(T*)(mem + idx);<br />
  }</p>
<p>template&lt;typename T&gt;<br />
T get(unsigned int base, unsigned int off)<br />
  {<br />
  return get(base + off);<br />
  }</p>
<p>template&lt;typename T&gt;<br />
void set(unsigned int idx, T&amp; t)<br />
  {<br />
  *(T*)(mem + idx) = t;<br />
  }<br />
};<br />
</code>It's easy to see how C++ grew out of Simula. There's very little difference here between a simulation and the real thing. This could be part of a primitive memory manager if you enhanced it a little. It grabs a piece of memory, and then treats it as though it were a T. I just used the get and set methods to allow me to easily manipulate C++ data types from a test harness. I can only think of two ways to do this in C#. First was the MemoryStream class, that would allow you to serialize your objects into and out of <span style="font-family:Courier New;">memory</span>, and the other would be the BitConverter class. BitConverter would be more efficient, but only supports primitive types. A serialized class is not much use at runtime, since you would have to deserialize it to use it.</p>
<p>I like this because it illustrates how a strongly typed language can be a hindrance. Last time I posted an entry criticising C# for lacking the power of C++, I got back some very intriguing responses that showed that with sufficient ingenuity, you can get around most hurdles in a language. So this time, I'm wondering how we could overcome this strong typing constraint. I know I'm a hypocrite for eulogising about strong typing in one post, and then criticising it in the very next. I guess I just want the power to not be bound by it, if I know what I am doing.</p>
<p>This must be an issue for C# communications libraries where they need to efficiently convert a byte stream into an object. Since all objects and classes are ultimately composed of primitives, I have to assume that recursive application of the BitConverter class is enough to impose shape on the data stream - but you would have to assign an object on a heap to store the data, so you can't do what is done above.</p>
<p>How would you do this in C#?</p>
