---
layout: post
title: Automated parallelization of Sequential Systems
date: 2006-11-28 11:41:01.000000000 +11:00
type: post
published: true
status: publish
categories: []
tags:
- C#
- Computer Science
- LINQ
meta: {}
author:
  login: aabs
  email: matthews.andrew@gmail.com
  display_name: Andrew Matthews
  first_name: Andrew
  last_name: Matthews
---
<p>I recently came across the <a href="http://research.microsoft.com/research/sv/dryad/">Dryad</a> project at MS Research. It is concerned with the development of automated systems to deploy sequential systems across parallel platforms. This is an interesting and topical issue at the moment because the advent of multi-core processors poses problems for developers. In C#, at the very least, there is no inherent parallelization of the language. Developers have to explicitly code a system with threading or <a href="http://gridenvy.wordpress.com/">grid computing</a> in mind. Coding in such a way is generally pretty hard, and fraught with peril to the unwary programmer, so any system that can ease the work required is likely to be finding its way into the .NET platform in the near future.</p>
<p>My impression from Dryad is that to make use of the multi-core processors we may have to change the way we design systems to allow automated parallelization. The Dryad project talks about a multileveled description of a system that incorporates declarations of the dataflow of the system as well as primitive operations to be performed on them. It seems to be targeted more at the massively computationally intensive operations traditionally performed in giant vector processors. What does it mean to those of us who develop distributed applications on web farms? I'm not sure, but I think that the trend will be the hot topic of the next few years.</p>
<p>At Tech Ed Sydney 2006, this issue was <a href="http://callvirt.net/files/DEV318.zip">highlighted</a> by <a href="http://callvirt.net/blog/">Joel Pobar</a> â€“ he pointed out that the declarative elements of technologies like <a href="http://msdn.microsoft.com/data/ref/linq/default.aspx?pull=/library/en-us/dndotnet/html/linqprojectovw.asp">LINQ</a> and <a href="http://research.microsoft.com/projects/ilx/fsharp.aspx">F#</a> provide a <a href="http://www.bluebytesoftware.com/blog/PermaLink,guid,81ca9c00-b43e-4860-b96b-4fd2bd735c9f.aspx">window of opportunity </a>to allow the runtime to incorporate structures that will make the life of systems like Dryad easier. An interesting trend is the gradual productisation of automated analysis and proof systems. The coolest thing I've seen lately is the <a href="http://research.microsoft.com/SpecSharp/">Spec#</a> project, again from MS Research which augments the C# IDE with various kinds of static analysis and automated theorem provers. For a while, I was a researcher on the <a href="http://www.it-innovation.soton.ac.uk/rapier/summary.htm">RAPIER</a> at the Parallel Application Centre at the University Of Southampton, UK. The project sought to integrate design, development, simulation and theorem proof tools for the development of real-time systems. I can't wait till such tools become the conventional static error checkers of IDEs like Visual Studio. It is discouraging that such tools are still not in the mainstream after 10 years of progress during which time software systems have become exponentially more complex.</p>
