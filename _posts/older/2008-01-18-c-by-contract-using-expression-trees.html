---
layout: post
title: C# by Contract - Using Expression Trees
date: 2008-01-18 16:00:48.000000000 +11:00
type: post
published: true
status: publish
categories:
- SemanticWeb
tags: []
meta:
  _edit_last: '154469'
  delicious: a:3:{s:5:"count";i:0;s:9:"post_tags";s:0:"";s:4:"time";i:1373459878;}
  reddit: a:2:{s:5:"count";i:0;s:4:"time";i:1373459880;}
author:
  login: aabs
  email: matthews.andrew@gmail.com
  display_name: Andrew Matthews
  first_name: Andrew
  last_name: Matthews
---
<p><a href="http://aabs.wordpress.com/2008/01/16/complex-assertions-using-c-30/" target="_blank">Last time</a> I created a simple, but powerful, little <a href="http://en.wikipedia.org/wiki/Design_by_contract" target="_blank">design by contract</a> library in C# 3.0. It took hardly any lines of code, and covered a broad range of possible usage scenarios. See <a href="http://archive.eiffel.com/doc/manuals/technology/contract/" target="_blank">here</a>, for more on DBC. One thing that bothered me was the fact that if something failed a check, it wouldn't tell what went wrong. I had a little free time today, so I thought I'd fix that. I wanted the exceptions it threw to have the text of the check we were performing. Developers need to see exactly what test failed. Generic "<em>assertion failed</em>" error messages are useless. </p>
<p>In my previous <a href="http://aabs.wordpress.com/2005/08/04/dbc-in-use-3/" target="_blank">efforts</a> at .NET DBC, I used strings to pass around the predicate body that I wished to evaluate. That allowed me to have a copy of the text handy, but with lots of drawbacks. In those frameworks, I created a new class that derived from the one being tested, but with the predicates inserted at the beginning and end of the methods they were attached to. That allowed me to do things like this:</p>
<pre><strong>[Requires(<span style="color:rgb(163,21,21);">"arg1 &gt; 10"</span>)]
[Requires(<span style="color:rgb(163,21,21);">"arg2 &lt; 100"</span>)]
[Ensures(<span style="color:rgb(163,21,21);">"$after(Prop1) == $before(Prop1) + 1"</span>)]</strong>
<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> TestMethod(<span style="color:rgb(0,0,255);">int</span> arg1, <span style="color:rgb(0,0,255);">int</span> arg2, <span style="color:rgb(0,0,255);">string</span> arg3)
{
    Prop1 = Prop1 + 1;
    System.Diagnostics.Debug.WriteLine(<span style="color:rgb(163,21,21);">"MyTestClass.TestMethod.Prop1 == "</span> + prop1.ToString());
}</pre>
<p>This let me to test private fields and properties, but on the other hand it stopped me from testing sealed classes. There's trade-offs no matter what you do unless you control the compiler, as is the case of <a href="http://en.wikipedia.org/wiki/Spec_sharp" target="_blank">Spec#</a>, <a href="http://en.wikipedia.org/wiki/Eiffel_%28programming_language%29" target="_blank">Eiffel</a> or <a href="http://en.wikipedia.org/wiki/D_%28programming_language%29#Example_3" target="_blank">D</a>. The attribute based approach is not dissimilar to <a href="http://research.microsoft.com/specsharp/" target="_blank">Spec#</a>, where a contract specification is part of the method signature rather than in the body of the method.</p>
<pre><span style="color:rgb(0,0,255);">int</span> BinarySearch(<span style="color:rgb(0,0,255);">object</span>[ ]! a, <span style="color:rgb(0,0,255);">object</span> o, <span style="color:rgb(0,0,255);">int</span> lo, <span style="color:rgb(0,0,255);">int</span> hi)
    <strong>requires 0 &lt;= lo &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.Length;</strong>
{ . . . }</pre></p>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>The difference is that Spec# uses syntactical enhancements, whereas I used Attributes. As I mentioned in <a href="http://aabs.wordpress.com/2007/10/20/lambda-functions-for-design-by-contract/" target="_blank">another post</a>, you can't use lambda functions in Attributes, nor could you use Expression trees based on lambda functions because the attribute itself cannot be generic. Another major drawback of the textual approach shown earlier is that it isn't type-safe. You could type any old garbage into that string, and you'd never know till run-time. You don't get intellisense either. We need a better way. </p>
<p><a href="http://weblogs.asp.net/scottgu/archive/2007/04/08/new-orcas-language-feature-lambda-expressions.aspx" target="_blank">Expression trees</a> are great for what we want, they <em>are</em> strongly typed, they <em>can </em>be assigned from lambda functions and they <em>needn't be compiled </em>until they're needed. Another cool thing is that the changes needed to use lambda expressions are trivial. Here's the Require extension method I showed you last time. It uses Expressions now.</p>
<pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">void</span> Require&lt;T&gt;(<span style="color:rgb(0,0,255);">this</span> T obj, <strong><span style="color:rgb(43,145,175);">Expression</span>&lt;<span style="color:rgb(43,145,175);">Func</span>&lt;T, <span style="color:rgb(0,0,255);">bool</span>&gt;&gt;</strong> pred)
{
    <strong><span style="color:rgb(0,0,255);">var</span> x = pred.Compile();</strong>
    <span style="color:rgb(0,0,255);">if</span> (!x(obj))
        <span style="color:rgb(0,0,255);">throw</span> <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">ContractException</span>(pred.ToString());
}</pre>
<p><a href="http://11011.net/software/vspaste"></a>All I had to do was convert the Func&lt;T, bool&gt; into an Expression&lt;Func&lt;T, bool&gt;&gt;. The compiler, seeing the method signature, knows that it needs to do some background conversion. It doesn't convert and pre-compile the lambda function that you pass into the extension method. Instead it first converts it to an expression tree. The Expression&lt;Func&lt;T, bool&gt;&gt; has a Compile method that will convert it to an anonymous method, which we call just before invoking it. You may be wondering why we would bother?</p>
<p>Because Expression&lt;Func&lt;T, bool&gt;&gt; also overrides ToString() giving the source code of the lambda function that it was created from. That's so cool! Now I can pass the code I was trying to run into the exception class if the code fails!. Here's the kind of output you get if the check fails.</p>
<blockquote>
<p>TestCase 'Tests.TestPredicates.MyFailingMethod'<br />failed: Contracts.ContractException : <strong>x =&gt; (value(Tests.TestPredicates).MyInt = x.before().MyInt</strong>)</p>
</blockquote>
<p>That's more readable than a plain old 'ApplicationException', don't you think?&nbsp; The predicates needn't be one-liners either; you can have very complex predicates in this system too. Here's an example from another project I'm working on. The use of scopes is more like the DBC implementation in the <a href="http://en.wikipedia.org/wiki/D_%28programming_language%29#Example_3" target="_blank">D Programming Language</a>.
<pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">bool</span> Insert(<span style="color:rgb(0,0,255);">string</span> location, <span style="color:rgb(0,0,255);">string</span> xmlFragment)
{
<strong>    <span style="color:rgb(0,0,255);">this</span>.Require(x =&gt; !<span style="color:rgb(0,0,255);">string</span>.IsNullOrEmpty(location));
    <span style="color:rgb(0,0,255);">this</span>.Require(x =&gt; !<span style="color:rgb(0,0,255);">string</span>.IsNullOrEmpty(xmlFragment));</strong>

    <span style="color:rgb(43,145,175);">XDocument</span> fragDoc = <span style="color:rgb(43,145,175);">XDocument</span>.Parse(xmlFragment);
    <span style="color:rgb(0,0,255);">object</span> tmpInsertPoint = LobDocument.XPathEvaluate(location);
    <span style="color:rgb(0,0,255);">bool</span> result = <span style="color:rgb(0,0,255);">false</span>;

    <strong><span style="color:rgb(0,0,255);">using</span> (<span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">PredicateScope</span>(<span style="color:rgb(0,0,255);">this</span>, fragDoc, tmpInsertPoint))
    {
        <span style="color:rgb(0,0,255);">this</span>.Ensure(x =&gt; tmpInsertPoint != <span style="color:rgb(0,0,255);">null</span>);</strong>

        <span style="color:rgb(0,0,255);">if</span> (tmpInsertPoint != <span style="color:rgb(0,0,255);">null</span>)
        {
            <span style="color:rgb(0,0,255);">if</span> (tmpInsertPoint <span style="color:rgb(0,0,255);">is</span> <span style="color:rgb(43,145,175);">XElement</span>)
            {
                <span style="color:rgb(43,145,175);">XElement</span> insertPoint = tmpInsertPoint <span style="color:rgb(0,0,255);">as</span> <span style="color:rgb(43,145,175);">XElement</span>;
                insertPoint.Add(fragDoc);
                result = <span style="color:rgb(0,0,255);">true</span>;
            }
        }

<strong>        <span style="color:rgb(0,0,255);">this</span>.Ensure(x =&gt;
            {
                <span style="color:rgb(43,145,175);">XElement</span> originalInsertPoint = tmpInsertPoint.before() <span style="color:rgb(0,0,255);">as</span> <span style="color:rgb(43,145,175);">XElement</span>;
                <span style="color:rgb(43,145,175);">XElement</span> currentInsertPoint = tmpInsertPoint <span style="color:rgb(0,0,255);">as</span> <span style="color:rgb(43,145,175);">XElement</span>;
                <span style="color:rgb(0,0,255);">int</span> countbefore = originalInsertPoint.Elements(fragDoc.Root.Name).Count();
                <span style="color:rgb(0,0,255);">int</span> countafter = currentInsertPoint.Elements(fragDoc.Root.Name).Count();
                <span style="color:rgb(0,0,255);">return</span> countafter == (countbefore + 1);
            });</strong>
    }
    <span style="color:rgb(0,0,255);">return</span> result;
}
</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>This is a fairly advanced use of lambdas and expression trees, but it certainly doesn't plumb the depths of what we could do. Those of you who've read some of the stuff I did in '06 and '07 on the <a href="http://aabs.wordpress.com/linq/" target="_blank">internals of LINQ</a> will remember that expression trees will be storing references to all the properties and other parameters of the lambda function. That means we can add them to the ContractException. We can also show what values they were before and after the operation. Perhaps next time I'll explore what can be done with all that extra data we've now got. </p>
<p>Till then, enjoy!</p>
