---
layout: post
title: Using Mock Objects When Testing LINQ Code
date: 2007-06-26 12:56:49.000000000 +10:00
type: post
published: true
status: publish
categories: []
tags:
- C#
- LINQ
- programming
meta:
  _oembed_726fdada3fb16615a1e3a7470cde5540: '{{unknown}}'
  _oembed_16937a586265f7b7f1748068eb4cd3b9: '{{unknown}}'
  _oembed_5e1477874fc1c5c4e114cfa668c75ba2: '{{unknown}}'
author:
  login: aabs
  email: matthews.andrew@gmail.com
  display_name: Andrew Matthews
  first_name: Andrew
  last_name: Matthews
---
<p>I was wondering the other day whether LINQ could be used with NMock easily. One problem with testing code that has not been written to work with unit tests is that if you test business logic, you often end up making multiple round-trips to the database for each test run. With a very large test suite that can turn a few minute's work into hours for a test suite. the best approach to this is to use mock data access components to dispense canned results, rather than going all the way through to the database.</p>
<p>After a little thought it became clear that all you have to do is override the <strong><em>IOrderedQueryable&lt;T&gt;.GetEnumerator()</em></strong> method to return an enumerator to a&nbsp;set of canned results and you could pretty much impersonate a LINQ to SQL Table (which is the <strong><em>IOrderedQueryable</em></strong> implementation for LINQ to SQL). I had a spare few minutes the other day while the kids were going to sleep and I decided to give it a go, to see what was involved.</p>
<p>I'm a great believer in the medicinal uses of mock objects. Making your classes testable using mocking enforces a level of encapsulation that adds good structure to your code. I find that the end results are often much cleaner if you design your systems with mocking in mind.</p>
<p>Lets start with a class that you were querying over in your code. This is the type that you are expecting to get back from your query. </p>
<pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> <span style="color:rgb(43,145,175);">MyEntity
</span>{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">string</span> Name
    {
        <span style="color:rgb(0,0,255);">get</span> { <span style="color:rgb(0,0,255);">return</span> name; }
        <span style="color:rgb(0,0,255);">set</span> { name = <span style="color:rgb(0,0,255);">value</span>; }
    }

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">int</span> Age
    {
        <span style="color:rgb(0,0,255);">get</span> { <span style="color:rgb(0,0,255);">return</span> age; }
        <span style="color:rgb(0,0,255);">set</span> { age = <span style="color:rgb(0,0,255);">value</span>; }
    }

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">string</span> Desc
    {
        <span style="color:rgb(0,0,255);">get</span> { <span style="color:rgb(0,0,255);">return</span> desc; }
        <span style="color:rgb(0,0,255);">set</span> { desc = <span style="color:rgb(0,0,255);">value</span>; }
    }

    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">string</span> name;
    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">int</span> age;
    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">string</span> desc;
}
</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>Now you need to create a new context object derived from the DLINQ <strong><em>DataContext</em></strong> class, but providing a new constructor function. You can create other ways to insert the data you want your query to return, but the constructor is all that is necessary for this simple example.</p>
<pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> <span style="color:rgb(43,145,175);">MockContext</span> : <span style="color:rgb(43,145,175);">DataContext
</span>{
<span style="color:rgb(0,0,255);">    #region</span> constructors

    <span style="color:rgb(0,0,255);">public</span> MockContext(<span style="color:rgb(43,145,175);">IEnumerable</span> col):<span style="color:rgb(0,0,255);">base</span>(<span style="color:rgb(163,21,21);">""</span>)
    {
        User = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">MockQuery</span>&lt;<span style="color:rgb(43,145,175);">MyEntity</span>&gt;(col);
    }
    <font color="#008000">// other constructors removed for readability</font>
<span style="color:rgb(0,0,255);">    #endregion
</span>    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(43,145,175);">MockQuery</span>&lt;<span style="color:rgb(43,145,175);">MyEntity</span>&gt; User;
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>Note that you are passing in an untyped&nbsp;<strong><em>IEnumerable</em></strong> rather than an <strong><em>IEnumerable&lt;T&gt;</em></strong> or a concrete collection class. The reason is that when you make use of projections in LINQ, the type gets transformed along the way. Consider the following:</p>
<pre>var q = from u <span style="color:rgb(0,0,255);">in</span> db.User
        where u.Name.Contains(<span style="color:rgb(163,21,21);">"Andrew"</span>) &amp;&amp; u.Age &lt; 40
        select <span style="color:rgb(0,0,255);">new</span> {u.Age};
</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>The result of <strong><em>db.User</em></strong> is an <strong><em>IOrderedQueryable&lt;User&gt;</em></strong> query class which is derived from <strong><em>IEnumerable&lt;User&gt;</em></strong>. But the result that goes into <strong><em>q</em></strong> is an <strong><em>IEnumerable</em></strong> of some anonymous type created specially for the occasion. there&nbsp;is a&nbsp;step along the way when the <strong><em>IQueryable&lt;User&gt;</em></strong> gets replaced with an <strong><em>IQueryable&lt;AnonType&gt;</em></strong>.&nbsp;If I set the type on the enumerator of the canned results, I would have to keep track of them with each call to <strong><em>CreateQuery</em></strong> in my Mock Query class. By using <strong><em>IEnumerable</em></strong>, I can just pass it around till I need it, then just enumerate the collection with a custom iterator, casting the types to what I ultimately need as I go.</p>
<p>The query object also has a constructor that takes an <strong><em>IEnumerable</em></strong>, and it keeps that till <strong><em>GetEnumerator()</em></strong> gets called later on. <strong><em>CreateQuery</em></strong> and <strong><em>CloneQueryForNewType</em></strong> just pass the <strong><em>IEnumerable </em></strong>around till the time is right. <strong><em>GetEnumerator</em></strong> just iterates the collection in the <strong><em>cannedResponse</em></strong> iterator casting them to the return type expected for the resulting query.</p>
<pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> <span style="color:rgb(43,145,175);">MockQuery</span>&lt;T&gt; : <span style="color:rgb(43,145,175);">IOrderedQueryable</span>&lt;T&gt;
{
    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">readonly</span> <span style="color:rgb(43,145,175);">IEnumerable</span> cannedResponse;

    <span style="color:rgb(0,0,255);">public</span> MockQuery(<span style="color:rgb(43,145,175);">IEnumerable</span> cannedResponse)
    {
        <span style="color:rgb(0,0,255);">this</span>.cannedResponse = cannedResponse;
    }

    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(43,145,175);">Expression</span> expression;
    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(43,145,175);">Type</span> elementType;

<span style="color:rgb(0,0,255);">    #region</span> IQueryable&lt;T&gt; Members

    <span style="color:rgb(43,145,175);">IQueryable</span>&lt;S&gt; <span style="color:rgb(43,145,175);">IQueryable</span>&lt;T&gt;.CreateQuery&lt;S&gt;(<span style="color:rgb(43,145,175);">Expression</span> expression)
    {
        <span style="color:rgb(43,145,175);">MockQuery</span>&lt;S&gt; newQuery = CloneQueryForNewType&lt;S&gt;();
        newQuery.expression = expression;
        <span style="color:rgb(0,0,255);">return</span> newQuery;
    }

    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(43,145,175);">MockQuery</span>&lt;S&gt; CloneQueryForNewType&lt;S&gt;()
    {
        <span style="color:rgb(0,0,255);">return</span> <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">MockQuery</span>&lt;S&gt;(cannedResponse);
    }
<span style="color:rgb(0,0,255);">    #endregion

    #region</span> IEnumerable&lt;T&gt; Members
    <span style="color:rgb(43,145,175);">IEnumerator</span>&lt;T&gt; <span style="color:rgb(43,145,175);">IEnumerable</span>&lt;T&gt;.GetEnumerator()
    {
        <span style="color:rgb(0,0,255);">foreach</span> (T t <span style="color:rgb(0,0,255);">in</span> cannedResponse)
        {
            <span style="color:rgb(0,0,255);">yield</span> <span style="color:rgb(0,0,255);">return</span> t;
        }
    }
<span style="color:rgb(0,0,255);">    #endregion
</span><span style="color:rgb(0,0,255);">
    #region</span> IQueryable Members
    <span style="color:rgb(43,145,175);">Expression</span> <span style="color:rgb(43,145,175);">IQueryable</span>.Expression
    {
        <span style="color:rgb(0,0,255);">get</span> { <span style="color:rgb(0,0,255);">return</span> System.Expressions.<span style="color:rgb(43,145,175);">Expression</span>.Constant(<span style="color:rgb(0,0,255);">this</span>); }
    }

    <span style="color:rgb(43,145,175);">Type</span> <span style="color:rgb(43,145,175);">IQueryable</span>.ElementType
    {
        <span style="color:rgb(0,0,255);">get</span> { <span style="color:rgb(0,0,255);">return</span> elementType; }
    }
<span style="color:rgb(0,0,255);">    #endregion
</span>}
</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>For the sake of readability I have left out the required interface methods that were not implemented, since they play no part in this solution. Now lets look at a little test harness:</p>
<pre><span style="color:rgb(0,0,255);">class</span> <span style="color:rgb(43,145,175);">Program
</span>{
    <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">void</span> Main(<span style="color:rgb(0,0,255);">string</span>[] args)
    {
        <span style="color:rgb(43,145,175);">MockContext</span> db = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">MockContext</span>(GetMockResults());

        var q = from u <span style="color:rgb(0,0,255);">in</span> db.User
                where u.Name.Contains(<span style="color:rgb(163,21,21);">"Andrew"</span>) &amp;&amp; u.Age &lt; 40
                select u;
        <span style="color:rgb(0,0,255);">foreach</span> (<span style="color:rgb(43,145,175);">MyEntity</span> u <span style="color:rgb(0,0,255);">in</span> q)
        {
            <span style="color:rgb(43,145,175);">Debug</span>.WriteLine(<span style="color:rgb(0,0,255);">string</span>.Format(<span style="color:rgb(163,21,21);">"entity {0}, {1}, {2}"</span>, u.Name, u.Age, u.Desc));
        }
    }

    <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(43,145,175);">IEnumerable</span> GetMockResults()
    {
        <span style="color:rgb(0,0,255);">for</span> (<span style="color:rgb(0,0,255);">int</span> i = 0; i &lt; 20; i++)
        {
            <span style="color:rgb(43,145,175);">MyEntity</span> r = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">MyEntity</span>();
            r.Name = <span style="color:rgb(163,21,21);">"name "</span> + i;
            r.Age = 30 + i;
            r.Desc = <span style="color:rgb(163,21,21);">"desc "</span> + i;
            <span style="color:rgb(0,0,255);">yield</span> <span style="color:rgb(0,0,255);">return</span> r;
        }
    }
}</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>The only intrusion here is the explicit use of <strong><em>MockContext</em></strong>. In the production code that is to be tested, you can't just go inserting <strong><em>MockContext</em></strong> where you would have used the SqlMetal generated context. You need to use a class factory that will allow you to provide the <strong><em>MockContext</em></strong> on demand in a unit test, but dispense a true LINQ to SQL context when in production. That way, all client code will just use mock data without knowing it.</p>
<p>Here's the pattern that I generally follow. I got it from the Java community, but I can't remember where:</p>
<pre><span style="color:rgb(0,0,255);">class</span> <span style="color:rgb(43,145,175);">DbContextClassFactory
</span>{
    <span style="color:rgb(0,0,255);">class</span> <span style="color:rgb(43,145,175);">Environment
</span>    {
        <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">bool</span> inUnitTest = <span style="color:rgb(0,0,255);">false</span>;

        <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">bool</span> InUnitTest
        {
            <span style="color:rgb(0,0,255);">get</span> { <span style="color:rgb(0,0,255);">return</span> <span style="color:rgb(43,145,175);">Environment</span>.inUnitTest; }
            <span style="color:rgb(0,0,255);">set</span> { <span style="color:rgb(43,145,175);">Environment</span>.inUnitTest = <span style="color:rgb(0,0,255);">value</span>; }
        }
        <span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(43,145,175);">DataContext</span> objectToDispense = <span style="color:rgb(0,0,255);">null</span>;

        <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(43,145,175);">DataContext</span> ObjectToDispense
        {
            <span style="color:rgb(0,0,255);">get</span> { <span style="color:rgb(0,0,255);">return</span> <span style="color:rgb(43,145,175);">Environment</span>.objectToDispense; }
            <span style="color:rgb(0,0,255);">set</span> { <span style="color:rgb(43,145,175);">Environment</span>.objectToDispense = <span style="color:rgb(0,0,255);">value</span>; }
        }
    }

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">object</span> GetDB()
    {
        <span style="color:rgb(0,0,255);">if</span> (<span style="color:rgb(43,145,175);">Environment</span>.InUnitTest)
            <span style="color:rgb(0,0,255);">return</span> <span style="color:rgb(43,145,175);">Environment</span>.ObjectToDispense;
        <span style="color:rgb(0,0,255);">return</span> <span style="color:rgb(0,0,255);">new</span> TheRealContext() <span style="color:rgb(0,0,255);">as</span> <span style="color:rgb(43,145,175);">DataContext</span>;
    }
}
</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>Now you can&nbsp;create your query like this:</p>
<pre>DbContextClassFactory.Environment.ObjectToDispense = <span style="color:rgb(0,0,255);">new</span> MockContext(GetMockResults());
var q = from u <span style="color:rgb(0,0,255);">in</span> DbContextClassFactory.GetDB() where ...</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>And your client code will use the <strong><em>MockContext</em></strong> if there is one, otherwise it will use a LINQ to SQL context to talk to the real database. Perhaps we should call this <em>Mockeries</em> rather than Mock Queries. What do you think?</p>
