---
layout: post
title: LinqToRdf - Designing a Query Provider
date: 2007-06-05 10:04:01.000000000 +10:00
type: post
published: true
status: publish
categories: []
tags:
- C#
- Computer Science
- LINQ
- programming
meta:
  _oembed_33b87493bafb0f8c390cb22df3138dfc: '{{unknown}}'
  _oembed_2b4bf565e6547cb0f351fbcb2d8db911: '{{unknown}}'
author:
  login: aabs
  email: matthews.andrew@gmail.com
  display_name: Andrew Matthews
  first_name: Andrew
  last_name: Matthews
---
<p>When I started implementing the SPARQL support in LINQ to RDF, I decided that I needed to implement as much of the <a href="http://download.microsoft.com/download/5/8/6/5868081c-68aa-40de-9a45-a3803d8134b8/standard_query_operators.doc" target="_blank">standard query operators</a> as possible. SPARQL is a very rich query language that bears a passing syntactical resemblance to SQL. It didn't seem unreasonable to expect most of the operators of LINQ to SQL to be usable with SPARQL. With this post I thought I'd pass on a few design notes that&nbsp;I have gathered during the work to date on the SPARQL query provider.</p>
<p>The different components of a LINQ query get converted into successive calls to your query class. My class is called SparqlQuery&lt;T&gt;. If you had a query like this:</p>
<pre>[<span style="color:rgb(0,128,128);">TestMethod</span>]
<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> SparqlQueryOrdered()
{
    <span style="color:rgb(0,0,255);">string</span> urlToRemoteSparqlEndpoint = <span style="color:rgb(128,0,0);">@"http://someUri"</span>;
    <span style="color:rgb(0,128,128);">TripleStore</span> ts = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(0,128,128);">TripleStore</span>();
    ts.EndpointUri = urlToRemoteSparqlEndpoint;
    ts.QueryType = <span style="color:rgb(0,128,128);">QueryType</span>.RemoteSparqlStore;
    <span style="color:rgb(0,128,128);">IRdfQuery</span>&lt;<span style="color:rgb(0,128,128);">Track</span>&gt; qry = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(0,128,128);">RDF</span>(ts).ForType&lt;<span style="color:rgb(0,128,128);">Track</span>&gt;(); 
    var q = from t <span style="color:rgb(0,0,255);">in</span> qry
        where t.Year == 2006 &amp;&amp;
        t.GenreName == <span style="color:rgb(128,0,0);">"History 5 | Fall 2006 | UC Berkeley"</span> 
        orderby t.FileLocation
        select <span style="color:rgb(0,0,255);">new</span> {t.Title, t.FileLocation};
    <span style="color:rgb(0,0,255);">foreach</span>(var track <span style="color:rgb(0,0,255);">in</span> q){
        <span style="color:rgb(0,128,128);">Trace</span>.WriteLine(track.Title + <span style="color:rgb(128,0,0);">": "</span> + track.FileLocation);
    }        
}
</pre>
<p>This would roughly equate to the following code, using the extension method syntax:</p>
<pre>[<span style="color:rgb(0,128,128);">TestMethod</span>]
<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> SparqlQueryOrdered()
{
    <span style="color:rgb(0,128,128);">ParameterExpression</span> t;
    <span style="color:rgb(0,0,255);">string</span> urlToRemoteSparqlEndpoint = <span style="color:rgb(128,0,0);"><a href="http://someUri">http://someUri</a></span>;
    <span style="color:rgb(0,128,128);">TripleStore</span> ts = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(0,128,128);">TripleStore</span>();
    ts.EndpointUri = urlToRemoteSparqlEndpoint;
    ts.QueryType = <span style="color:rgb(0,128,128);">QueryType</span>.RemoteSparqlStore;
    var q = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(0,128,128);">RDF</span>(ts).ForType&lt;<span style="color:rgb(0,128,128);">Track</span>&gt;()
        .<font color="#ff0000"><strong>Where</strong></font>&lt;<span style="color:rgb(0,128,128);">Track</span>&gt;(<span style="color:rgb(0,128,0);">/*create expression tree*/</span>)
        .<strong><font color="#ff0000">OrderBy</font></strong>&lt;<span style="color:rgb(0,128,128);">Track</span>, <span style="color:rgb(0,0,255);">string</span>&gt;(<span style="color:rgb(0,128,0);">/*create  expression tree*/</span>)
        .<font color="#ff0000"><strong>Select</strong></font>(<span style="color:rgb(0,128,0);">/*create  expression tree*/</span>;
    <span style="color:rgb(0,0,255);">foreach</span> (var track <span style="color:rgb(0,0,255);">in</span> q)
    {
        <span style="color:rgb(0,128,128);">Trace</span>.WriteLine(track.Title + <span style="color:rgb(128,0,0);">": "</span> + track.FileLocation);
    }
}
</pre>
<p>The bold red method calls are the succession of calls to the query's CreateQuery method. That might not be immediately obvious from looking at the code. In fact it's downright unobvious! There's compiler magic going on in this, that you don't see. Anyway, what happens is that you end up getting a succession of calls into your IQueryable&lt;T&gt;.CreateQuery() method. And that's what we are mostly concerned about when creating a query provider.</p>
<p>The last I blogged about the CreateQuery method I gave a method with a switch statement that identified the origin of the call (i.e. Where, OrderBy, Select or whatever) and dispatched the call off to be immediately processed. I now realise that that is not the best way to do it. If I try to create my SPARQL query in one pass, I will not have much of a chance to perform optimization or disambiguation. If I generate the projection before I know what fields were important, I would probably end up having to get everything back and filter on receipt of all the data.&nbsp;I think Bart De Smet was faced with that problem&nbsp;with LINQ to LDAP (LDAP doesn't support projections) so he had to get everything back.&nbsp;SPARQL does support projections, and that means I can't generate the SPARQL query string till after I know what to get back from the Select call.</p>
<p>My solution to this is to keep all the calls into the CreateQuery in a Hashtable so that I can use them all together in the call to GetEnumerator. That gives me the chance to do any amount of analysis on the expression trees I've got stored, before I convert them into a SPARQL query. The CreateQuery method now looks like this:</p>
<pre><span style="color:rgb(0,0,255);">protected</span> <span style="color:rgb(0,128,128);">Dictionary</span>&lt;<span style="color:rgb(0,0,255);">string</span>, <span style="color:rgb(0,128,128);"></span><span style="color:rgb(0,128,128);">MethodCallExpression</span>&gt; expressions;
</pre>
<pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,128,128);">IQueryable</span>&lt;S&gt; CreateQuery&lt;S&gt;(<span style="color:rgb(0,128,128);">Expression</span> expression)
{
    <span style="color:rgb(0,128,128);">SparqlQuery</span>&lt;S&gt; newQuery = CloneQueryForNewType&lt;S&gt;();

    <span style="color:rgb(0,128,128);">MethodCallExpression</span> call = expression <span style="color:rgb(0,0,255);">as</span> <span style="color:rgb(0,128,128);">MethodCallExpression</span>;
    <span style="color:rgb(0,0,255);">if</span> (call != <span style="color:rgb(0,0,255);">null</span>)
    {
        Expressions[call.Method.Name] = call;
    }
    <span style="color:rgb(0,0,255);">return</span> newQuery;
}
</pre>
<p><a href="http://11011.net/software/vspaste"></a></p>
<p>This approach helps because it makes it much simpler to start adding the other query operators.</p>
<p>I also been doing a fair bit of tidying up as I go along. My GetEnumerator method now reflects the major grammatical components of the SPARQL spec for SELECT queries.</p>
<pre><span style="color:rgb(0,0,255);">private</span> <span style="color:rgb(0,0,255);">void</span> CreateQuery(<span style="color:rgb(0,128,128);">StringBuilder</span> sb)
{
    <span style="color:rgb(0,0,255);">if</span>(Expressions.ContainsKey(<span style="color:rgb(128,0,0);">"Where"</span>))
    {
        <span style="color:rgb(0,128,0);">// first parse the where expression to get the list of parameters to/from the query.
</span>        <span style="color:rgb(0,128,128);">StringBuilder</span> sbTmp = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(0,128,128);">StringBuilder</span>();
        ParseQuery(Expressions[<span style="color:rgb(128,0,0);">"Where"</span>].Parameters[1], sbTmp);
        <span style="color:rgb(0,128,0);">//sbTmp now contains the FILTER clause so save it somewhere useful.
</span>        Query = sbTmp.ToString();
        <span style="color:rgb(0,128,0);">// now store the parameters where they can be used later on.
</span>        queryGraphParameters.AddAll(Parser.Parameters);
    }
    CreateProlog(sb);
    CreateDataSetClause(sb);
    CreateProjection(sb);
    CreateWhereClause(sb);
    CreateSolutionModifier(sb);
}
</pre>
<p><a href="http://11011.net/software/vspaste"></a>The If clause checks whether the query had a where clause. If it did, it parses it, creating the FILTER expression, and in the process gathering some valuable information about what members from T were referenced in the where clause. This information is useful for other tasks, so it gets done in advance of creating the Where clause.</p>
