---
layout: post
title: Complex Assertions using C# 3.0
date: 2008-01-16 13:44:35.000000000 +11:00
type: post
published: true
status: publish
categories:
- SemanticWeb
tags: []
meta:
  _edit_last: '154469'
  delicious: a:3:{s:5:"count";s:1:"0";s:9:"post_tags";s:0:"";s:4:"time";s:10:"1337868742";}
  reddit: a:2:{s:5:"count";s:1:"0";s:4:"time";s:10:"1337868744";}
author:
  login: aabs
  email: matthews.andrew@gmail.com
  display_name: Andrew Matthews
  first_name: Andrew
  last_name: Matthews
---
<p>Recently I <a href="http://aabs.wordpress.com/2007/10/20/lambda-functions-for-design-by-contract/" target="_blank">attempted</a> to implement a declarative predicate checking system to allow design by contract (DBC) within C# 3.0. I was not successful due to a limitation in the kind of parameters one can pass to an Attribute constructor in .NET (no lambdas). I thought I'd just follow that up with a simpler model based on extension methods.</p>
<pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">class</span> <span style="color:rgb(43,145,175);">Predicates
</span>{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">void</span> Assert&lt;T&gt;(<span style="color:rgb(0,0,255);">this</span> T obj, <span style="color:rgb(43,145,175);">Func</span>&lt;T, <span style="color:rgb(0,0,255);">bool</span>&gt; pred)
    {
        <span style="color:rgb(0,0,255);">if</span> (!pred(obj))
            <span style="color:rgb(0,0,255);">throw</span> <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">ApplicationException</span>();
    }
}</pre>
<p>This simple extension method can be attached to any object allowing Ensures and Requires like this.</p>
<pre><span style="color:rgb(0,0,255);">int</span> MyIntProp{<span style="color:rgb(0,0,255);">get</span>;<span style="color:rgb(0,0,255);">set</span>;}</pre>
<pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> MyMethod()
{
    <span style="color:rgb(0,0,255);">this</span>.Assert(x =&gt; x.MyIntProp &lt; 10);
    MyIntProp += 10;
    <span style="color:rgb(0,0,255);">this</span>.Assert(x =&gt; x.MyIntProp &gt;= 10);
}
</pre>
<p><a href="http://11011.net/software/vspaste"></a>This is a nice clear implementation that is good for validation. But I think that I can extend it further by exploiting serialization of snapshots within a scope to allow before/after analysis within the scope. Here's what I want to be able to write:</p>
<pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> MyBetterMethod()
{
    <span style="color:rgb(0,0,255);">this</span>.Require(x =&gt; x.MyIntProp &lt; 10);
    MyIntProp += 10;
    <span style="color:rgb(0,0,255);">this</span>.Ensure(x =&gt; x.MyIntProp == x.before().MyIntProp + 10);
}</pre>
<p>Well, my recent writings about the Ambient Context pattern might give you a clue about how I would manage the scope. The first thing I need to be able to do is store a snapshot of the object before it gets tested by the Require. I chose an IDisposable object so that I can clean up after myself without the danger of having the serialized guts of objects lying around everywhere.</p>
<pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> <span style="color:rgb(43,145,175);">PredicateScope</span> : <span style="color:rgb(43,145,175);">IDisposable
</span>{
    [<span style="color:rgb(43,145,175);">ThreadStatic</span>]
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(43,145,175);">Stack</span>&lt;<span style="color:rgb(43,145,175);">PredicateScope</span>&gt; Scopes = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">Stack</span>&lt;<span style="color:rgb(43,145,175);">PredicateScope</span>&gt;();
    <span style="color:rgb(0,0,255);">internal</span> <span style="color:rgb(0,0,255);">readonly</span> <span style="color:rgb(43,145,175);">Dictionary</span>&lt;<span style="color:rgb(0,0,255);">object</span>, <span style="color:rgb(0,0,255);">string</span>&gt; Snapshots = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">Dictionary</span>&lt;<span style="color:rgb(0,0,255);">object</span>, <span style="color:rgb(0,0,255);">string</span>&gt;();
    <span style="color:rgb(0,0,255);">internal</span> <span style="color:rgb(0,0,255);">readonly</span> <span style="color:rgb(43,145,175);">Dictionary</span>&lt;<span style="color:rgb(0,0,255);">object</span>, <span style="color:rgb(0,0,255);">object</span>&gt; DeserializedSnapshots = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">Dictionary</span>&lt;<span style="color:rgb(0,0,255);">object</span>, <span style="color:rgb(0,0,255);">object</span>&gt;();

    <span style="color:rgb(0,0,255);">public</span> PredicateScope(<span style="color:rgb(0,0,255);">params</span> <span style="color:rgb(0,0,255);">object</span>[] objects)
    {
        <span style="color:rgb(0,0,255);">foreach</span> (<span style="color:rgb(0,0,255);">object</span> obj <span style="color:rgb(0,0,255);">in</span> objects)
        {
            Snapshots.Add(obj, CreateSnapShot(obj));
        }
        Scopes.Push(<span style="color:rgb(0,0,255);">this</span>);
    }
    <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">string</span> CreateSnapShot(<span style="color:rgb(0,0,255);">object</span> obj)
    {
</pre>
<pre>        <span style="color:rgb(43,145,175);">XmlSerializer</span> serializer = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">XmlSerializer</span>(obj.GetType());
        <span style="color:rgb(43,145,175);">StringWriter</span> sr = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">StringWriter</span>();
        serializer.Serialize(sr, obj);
        <span style="color:rgb(0,0,255);">return</span> sr.ToString();
</pre>
<p><a href="http://11011.net/software/vspaste"></a>
<pre>    }

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> Dispose()
    {
        Snapshots.Clear();
        Scopes.Pop();
    }
}</pre>
<p>You just pass the scope object whatever objects you intend to test later on. It takes snapshots of the objects and stores them away for later reference. It also maintains a stack, so it can be nested. Strictly speaking this is unnecessary, but I figure it might come in handy later on.</p>
<p>My Assertion methods are pretty much the same, but they're now augmented by a "before" extension method that will get a snapshot keyed to the object it's extending, and return that instead.</p>
<pre><span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">class</span> <span style="color:rgb(43,145,175);">Predicates
</span>{
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">void</span> Require&lt;T&gt;(<span style="color:rgb(0,0,255);">this</span> T obj, <span style="color:rgb(43,145,175);">Func</span>&lt;T, <span style="color:rgb(0,0,255);">bool</span>&gt; pred)
    {
        <span style="color:rgb(0,0,255);">if</span> (!pred(obj))
            <span style="color:rgb(0,0,255);">throw</span> <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">ApplicationException</span>();
    }

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> <span style="color:rgb(0,0,255);">void</span> Ensure&lt;T&gt;(<span style="color:rgb(0,0,255);">this</span> T obj, <span style="color:rgb(43,145,175);">Func</span>&lt;T, <span style="color:rgb(0,0,255);">bool</span>&gt; pred)
    {
        <span style="color:rgb(0,0,255);">if</span> (!pred(obj))
            <span style="color:rgb(0,0,255);">throw</span> <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">ApplicationException</span>();
    }

    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">static</span> T before&lt;T&gt;(<span style="color:rgb(0,0,255);">this</span> T obj) <span style="color:rgb(0,0,255);">where</span> T : <span style="color:rgb(0,0,255);">class
</span>    {
        <span style="color:rgb(0,0,255);">if</span> (obj == <span style="color:rgb(0,0,255);">null</span>)
            <span style="color:rgb(0,0,255);">throw</span> <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">ArgumentNullException</span>(<span style="color:rgb(163,21,21);">"obj cannot be null"</span>);

        <span style="color:rgb(43,145,175);">PredicateScope</span> ctx = <span style="color:rgb(43,145,175);">PredicateScope</span>.Scopes.Peek();
        <span style="color:rgb(0,0,255);">if</span> (ctx == <span style="color:rgb(0,0,255);">null</span>) <span style="color:rgb(0,0,255);">return</span> <span style="color:rgb(0,0,255);">default</span>(T);

        <span style="color:rgb(0,0,255);">if</span> (ctx.DeserializedSnapshots.ContainsKey(obj))
            <span style="color:rgb(0,0,255);">return</span> ctx.DeserializedSnapshots[obj] <span style="color:rgb(0,0,255);">as</span> T;
</pre>
<pre>        <span style="color:rgb(0,0,255);">string</span> serializedObject = ctx.Snapshots[obj];
        <span style="color:rgb(43,145,175);">XmlSerializer</span> ser = <span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">XmlSerializer</span>(<span style="color:rgb(0,0,255);">typeof</span>(T));
        <span style="color:rgb(43,145,175);">XmlReader</span> reader = <span style="color:rgb(43,145,175);">XmlReader</span>.Create(<span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">StringReader</span>(serializedObject));
        <span style="color:rgb(0,0,255);">object</span> result = ser.Deserialize(reader);
        ctx.DeserializedSnapshots[obj] = result;
        <span style="color:rgb(0,0,255);">return</span> result <span style="color:rgb(0,0,255);">as</span> T;</pre>
<p><a href="http://11011.net/software/vspaste"></a><a href="http://11011.net/software/vspaste"></a>
<pre>    }
}</pre>
<p>The before method gets the snapshot out of the scope, and returns that. You can then use it in your assertions in exactly the same way as the original object.</p>
<pre>[<span style="color:rgb(43,145,175);">TestFixture</span>, <span style="color:rgb(43,145,175);">DataContract</span>]
<span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">class</span> <span style="color:rgb(43,145,175);">MyClass
</span>{
    [<span style="color:rgb(43,145,175);">DataMember</span>]
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">int</span> MyInt { <span style="color:rgb(0,0,255);">get</span>; <span style="color:rgb(0,0,255);">set</span>; }
    [<span style="color:rgb(43,145,175);">Test</span>]
    <span style="color:rgb(0,0,255);">public</span> <span style="color:rgb(0,0,255);">void</span> MyMethod()
    {
        <span style="color:rgb(0,0,255);">using</span> (<span style="color:rgb(0,0,255);">new</span> <span style="color:rgb(43,145,175);">PredicateScope</span>(<span style="color:rgb(0,0,255);">this</span>))
        {
            <span style="color:rgb(0,0,255);">this</span>.Require(x =&gt; x.MyInt &lt; 10);
            MyInt += 10;
            <span style="color:rgb(0,0,255);">this</span>.Ensure(x =&gt; MyInt == x.before().MyInt + 10);
        }
    }
}</pre>
<p>Obviously, for production use you'd have to ensure this stuff didn't get run by using ConditionalAttribute. It would affect performance. But for debugging it can be a godsend.</p>
